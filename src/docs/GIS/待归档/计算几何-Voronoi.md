---
title: 计算几何-Voronoi
article: false
category:
  - 待归档
  - 计算几何
  - Voronoi
---
## Voronoi
- 对整个空间进行剖分，剖分的基本单元称为cell
- 以下都是二维讨论
### 特点
- 相对于其他cell的基点site，每个cell中，任何位置离该cell的基点的位置是最近的
- cell的组成：是由该基点和其他site的连线的平分线的某一段组成，是离它更近的半平面的交集
  - 本质上记录边界信息即可
  - 每个cell都是凸的，因为参与交的每一个半平面都是凸的
- 有的cell是封闭的，有的是无界的
  - 鸽巢原理
- 边edge：线段segment，开放的线段rays，直线lines
- 顶点vertex
- 特点
  - 等距性
  - 内空性
    - 每一个site都拥有一个非空的cell
      - site的圆disk，若半径足够小，必然落在cell中，即任何一个site对应的cell都不会是空的，
  - 空圆性
    - cell中非site的普通点，以该点位圆心，点到site的距离为半径画圆，该圆内部必然是空的(即不包含任何的site)
    - 若某个点x在edge上，画圆，因为想在两个site的平分线上，所以x到两个site的距离是相等的
      - 该圆内部不会有其他site
    - 若某个点x在vertex上，画圆，x是哪几个cell的公共部分，它的半径就是x到site的距离(三个距离相同),该圆依然是空的，且是最大空圆。这三个site共圆弧circle
      - 注意circle与disk的区别：disk实心，circle只考虑边界
  - 最近邻site的个数：即x的度数
    - 1个：x在cell内部
    - 2个：x在两个site的平分线上
    - 3个：x在certex上
  - 一般情况下：任何三角形的三条垂直平分线必然交于一点，该点称为三角形的外心，外心
    - 特殊情况：有不止三个site共圆(程序中需要考虑)
  - 动态情况x：以上考虑的都是静态x
    - x沿着某个Vedge行进，有个位置的最大空圆上不止只有两个site，此时x不能行进了，度是3，此时V会发生变化
      - split现象：沿着edge行进的边叫入边，当度数为3时，入边进行分叉，这两个分叉是两对site的平分线，此时该位置的最大空圆发生split，分成两个新的最大空圆，这两个空圆分别以两个分叉和两对site构成
    - 反过来，这种现象称为merge 
  - V图的复杂度
    - 先对V图进行界定，V图不是严格的图graph，rays只有一个端点，特殊情况下的lines没有端点
      - 将无界的edge连向无穷远的某一个点，这样V图就称为了一个严格意义上的graph(且是连通图)，可以进行复杂度讨论。(无穷远必然有edge是弯曲的，但是有定理已经说明，平面图中的edge不一定都是直的，曲边和直边完全是等价的)
        - site集的规模是和edge和vertex呈线性关系
          - 需要O(n)的空间存储和表示V图
            - 证明：
              - 某一方面  
                - 声明D是所有cell周长总和，每一条边贡献D为2，所以D=2e
                - 每个cell都是封闭的，至少有三条边，D>=3f,f指cell的个数
                -  3f =< D = 2e
              - 另一方面
                - 欧拉公式 
                  -  在任何一副平面图中，顶点的数目v，减去边的数目e，加上cell(面，face，face=cell+outer face(1))的数目f，减去连通域的数目c 恒等于 1
             - 联立不等式组，解得：对于由n个site组成的V图，其中v或e都与n呈线性关系
### 在计算机中存储和V图
- 可以存储以V图为基础的一系列的几何结构：subdivision(子区域剖分)
  - 存储为一张一张的face(cell)
    - 满足：
      - cells的并为整个平面
      - 两个face内部不会有交
      - 即无缝不重叠 
- 首先要存储和记录V图的元素：v、e、c。还需要记录关联关系incidence，为了更深入的查找
  - 借助DCEL双向链接边表数据结构
    - DCEL是基于边的结构，不仅适用于V图，还适用于一般的子区域剖分
    - 边分解技术
      - 将subdivision中连接于以任何两个顶点之间的无向边拆解成一对有向边，这一对是共存的、孪生的边，称为tiwn edges。半边称为half-edge
    - 准备三张表
      - edge list记录半边
        - id
        - twin，记录孪生边的引用，通过孪生边能找到半边
        - origin，ori，半边是由方向的，ori记录的是该半边起始的顶点site
        - incidence，inc，记录该半边参与围成(只是一段face的一段)的一个面face，规定，这张face的内部位于该半边的左侧
        - pred、succ，每一条半边都有唯一的一个predecessor半边和唯一的一个successor半边，为了找到当前半边的前驱和后继

      - vertex list记录顶点
        - id
        - x & y 
        - incidence,inc,任意一个顶点都有若干条边相关联，inc存储的是随机的一条特定的边：第一条向外发出的关联的半边the first outgoing incident incident half-face
      - face list 记录面
        - id
        - inc，每一张面都是由若干条半边围成，常遍历face，是由初始半边出发遍历，所以记录the first half-edge incident to the face form left，即分解出来的那条半边
    - ECEL结构调试时的陷阱
      - e->succ->twin != e->twin-pred
      - e->ori != e->twin->succ->ori
      - e->succ->ori != e->twin->ori
      - e->inc->inc != e
    - 应用：视频F-Applicaiton
### 讨论V图的难度
- (未理解，后续再看)
- 二维的V图：nlogn
#### V图的复杂度可否降低？
- 当输入子集中某部分已经排序好了(Sorted Sets)，V图的构造复杂度可否降低？
  - 例如，若凸包的点集极角排序好了，就可以省去GS算法的presorting，由nlong->n
  - 然而V图不能降低
    - 凸包称为combinatorial structures组合结构
    - V图称为geometric structures几何结构
    - 通过仿射变换能看出两者区别
      - 仿射变换：对平面进行某个方向的拉伸或压缩、错切
      - 在仿射变换下，凸包具有不变性，虽然形状有变化，但是结构(极点、非极点、极点和非极点的关系)没有变化(拓补结构不变)，凸包变换后还是凸包
      - 而凸包变换后会发生拓扑结构上的变化
        - 因为V图依赖的是距离，而放射变化恰巧会改变距离
### 构造VD
#### 数学定义方法Naive,n^3
- 一个cell一个cell的构造，然而不能用，不是整体,是一系列的cells
- 从某个site出发，naive无非就是将该site与其他site之间的平分线构造出来
  - 一开始只有一个site，其cell是整个平面
  - 引入一个site，计算平分线，做一次clipping
    - clipping：将当前的bisector与其他bisectors进行逐一求交，n^2
      - 又因为cell数量=site数量，n个，所以n^3。离nlogn下界非常远，所以要优化算法
  - 再引入...
#### 递增策略
- 逐一的引入site，每次都构造出其对应的cell
- 核心的步骤就是如何从k-1个点的VD，通过引入新的site，得到规模为k的VD。
  - 这一步骤实际上就是得到一个cell
  - 实际上就是在原先VD基础上，多一个cell
    - 多一块，之前的VD必然会少某些块。新生成的cell是由之前VD的若干个cell各自分出一部分区域而拼凑而成
      - 即要确定新cell与之前每个cell的边界
        - 如何确定每一条边界
          - 新site和已经存在的site的平分线
        - 然后通过DCEL获取平分线与其他cell的交点(logn)
        - 再通过交点和DCEL翻墙(访问twin edge,O(1))，找到隔壁的cell，要继续割让一部分
          - 割让的这部分起点已经确定，就是刚才获取到的交点
            - 重点是方向，方向就是这两个site的平分线O(1)
        - 继续翻墙...
        - 最终回到起点
  - 每次新引入的site的复杂度：边界数*logn，即nlogn。整个算法引入n个点，所以n^2*logn
#### 分而治之divide conquer
1. 对点进行预排序
- 使所有点，从左到右有序
2. 将排序后的算法作为递归算法的输入
- 递归关注的局部所需要的参数：所有点S，第i个点，第j个点
```js
// 递归算法伪代码
dacVD(S,i,j) {
  // 若i和j之间距离足够近，即剩下的点不足3个(退化情况)
  return j - i < 3 ? 
    // 直接构造VD
    trivialVD(S,i,j) :

    // 否则一般情况下，将整个的局部点集分解成更小的两个局部，且这两个规模都应该保持接近(分而治之的要求，要尽可能均匀的划分)
      // 将递归得到的两张子图合二为一
    merge(dacVD(S,i,(i+j)/2),dacVD(S,(i+j)/2 + i,j))
}

merge() {

}
```

- merge:
  - 两个cell之间有可能有重叠的部分
    - 因为他们原本都是一张完整的图，都必须完整的覆盖整个平面
  - 要先找到两个site的bisector平分线，bisector将整个平面分成左右两张半平面，half-planes，hL和hR
  - 用bisector解决两个冲突的cell 
    - 用hL对hR做裁剪，割掉一部分，剩下右侧部分
    - 对称的，用hR对hL做裁剪，割掉一部分，剩下左侧部分
    - 从而进行局部的合二为一
    - 然而效率较低
      - 用相关性，把那些需要解决冲突的cell对排列下来
        - 有一条裂缝(contour，轮廓线)，给出了那些cell需要缝合，且给出缝合的位置、缝合cell的次序
          - contour:是界于左边子图和右边子图之间的某个折中线
            - coutour上的任何一个点到左侧子集的site和右侧子集site的距离相等。即此时以这个点为圆心，到site的距离为半径，存在一个空圆，而这个点必然是在一条要合成的V的edge上。所以contour必然是两个子图合成后的V图的若干条edge前后依次相连构成的
          - coutour的性质：
            - y方向上的单调性：任何一条水平线与contour相交，至多有一个交点。没有分支
            - 从上到下追踪coutour，第一段必然是从左右两个子集上方的公切线(tangent)的bisector(O(n))，最后一段是左右两个子集下方的公切线(tangent)的bisector
            - coutour上面的Vedge的边数：左侧n个site，右侧m个site不超过n+m，因为site对contour长度的贡献不会超过1
          - 获取coutour
            - 获取contour的第一条边
            - 找到公切线O(n)
            - 求公切线的bisector：b
            - 顺着contour这条链，自顶而下迭代追踪
              - 迭代的每一步：找到左边V图的cell和右边V图的cell，并找到他们的bisector,用b解决两个cell的冲突：对他们用b进行裁切。此时要注意，bisector是最先从哪个cell出来的，先出来的就要替换为它同侧的一个后继。如何找到后继？沿着它所对应的交边，通过twin的引用，翻墙（O(1)）进入隔壁的哪个后继cell。这种替代可能发生在左侧，可能发生在右侧，无论左右都用后继取而代之。从而构成下一对需要排解冲突的cell对，对于新的cell对来说，他们的分界线bisector需要重新确定O(1)，思想类似二路归并。迭代一直到contour的最后一条边出来
           
      - 用bisector做裁剪再合并，效率低
        - 所以用coutour作裁剪再合并
      - 时间复杂度最重要的地方在于求交，当在两个cell公共部分 ，沿着bisector遍历的时候，究竟是从哪个cell退出来的，cell的哪个位置退出来的？不得不做一次求交intersection
        - 求交的复杂度：针对于一个cell，以一条bisector对其进行求交，找到翻墙的方向，蛮力法：对cell进行遍历O(n)，若同一个site的cell过大，则cell可能会被反复的遍历，最坏的情况下是O(n*m),太高
          - 要避免对同一个cell反复遍历
            - 利用凸形，任何一个cell都是凸的。每求交一次，都会相对于这个固定而言的cell，coutour会有一个拐弯turn，不管是原来的那一段，还是拐弯后的那一段，他们都是合并之后的那副V图的edge。而无论是裁剪之前的，还是裁减之后沿着coutour而言的边都是合并之后的围绕着同一个site的edge，他们应该构成一条凸的环路。在凸的环路上遍历的特点，从上而下行进时，任何一个拐弯都是沿着同一个方向，例如由左侧site生成的边都是向右拐(从上而下)，这些拐点必然是前后单调的，此时不用重新遍历cell获取起点，而是从上一个拐点开始。这样求所有的交点，累计复杂度不过是线性的，而不是蛮力法求每一个交点线性时间。所以整个算法的复杂度是nlogn，即之前推出的下界
#### 基于扫描线的算法
- 垂直的扫描线，从左到右
- 扫描线算法构造V图不可避免的问题是会发生回退，此算法使用xxx解决了该问题

- 回退的原因
  - 只有三个点，从上而下扫描，p和q扫描过了，r没有被扫描到时，不能确定由pq这两个site确定的bisector的终止位置(V图vertex的位置)，一般来说，只有扫描到r时，才能确定终止位置，因为v到pqr的距离相同，是三角形的外心。所以当扫描线扫到r时，确定v，此时需要将扫描线回退，用来正确的生成v，然而回退会影响效率，且使得算法很复杂，要考虑许多回退的情况。
- 如何避免回退：
  - 改造扫描线sweepline，不在是直的，而是由一系列的抛物线首尾连接(连接点交break points)而构成，叫做beach line海浪线，扫描线扫描的过程中，bp会不断的进行变化，将V图一点一点的绘制出来。此时扫描线由两部分组成：直的和抛物线形式的，
    - 为什么不会发生回溯
      - 一般情况下，凡是扫过的都不再使用了，而此时需要将他们保存下来，进一步复用。不再以常规的扫描线算法，分成未扫描和已经扫描过的两部分。而是对扫描过的进一部划分为两部分，一部分叫frozen冻结了的(抛物线之上的)，一部分叫unfrozen(抛物线之下，直线之上的)。
        - frozen中的点特性：他到直线扫描线sweepline的距离都会长于它到已经扫过site的距离的最小者。即人frozen中的任何一个点，它在最终的V图中具体应该归属于哪个cell已经确定了，它必然会归属于在上面已经扫描过的子集中离它最近的哪个site所对应的cell。对于未来来说，这些点已经不会再改变
      - bl特性：
        - 在x上是单调的，和任何一条垂直线都相交不超过一个点
        - bl上的每一段弧都来自一个抛物线
          - 抛物线，有一个准线，有一个交点，抛物线由所有距离这两个元素距离相等的点构成
            - 随着准线和交点的距离越来越近，抛物线开口越来越窄。特例：抛物线的准线与交点完全重合，有一条退化的抛物线，就是交点向上的一条射线
          - 准线即这里的扫描线，每一个扫描过的site都可以作为交点，并对应于一个抛物线。取这些抛物线的最小值，即最下方的点形成包络envelope，而包络即这里的beach line。
            - 有的抛物线的minimum可能会被其他屏蔽掉
      - bp的特点：
        - 每一个bp必然会在某一个edge上(重要，根据这条性质，勾勒出V图)
          - bp到pq这两个site的距离等于bp到准线的距离。而这三条距离相同且是最小的，意味着bp位于pq的平分线上，而这条平分线即是pq这两个site形成cell的edge
            - 随着sweepline的不断向下推进，bp也会向下推进，从而动态的把所有的edge绘画出来
              - 当sweepline碰到第三个site：r时，此时bp不是简单的bp，而是V图的vertex，因为vertex以三个site作为最近邻。此时平分线会在该bp处分裂split，会朝其他方向演化下去
- 但是在程序中，不能连续的将每一条edge都勾勒出来，因为这样做必须停留在所有的位置上，要处理无限个点，不现实
  - 要处理在一些特定位置上的点(event事件)即可
    - 哪些事件：bl的拓扑结构发生变化的时刻，而不变的时候，bl的那些bp在画直线，直线不需要中间绘制过程，只需要其什么时候发生或者出现
      - 第一类：site event站点事件
      - 第二类：circle event圆事件
        - ce是动态生成的，随着算法的进行，会发现新的ce，并加入到事件队列中
          - 关注bl上相邻的三段弧，他们有可能会存在一个潜在的ce，且ce没有被扫描线扫描到
            - 这三段弧对应的三个site，必然会定义一个圆，会确定一个潜在的ce，恰好取做圆的最下面的哪个点

