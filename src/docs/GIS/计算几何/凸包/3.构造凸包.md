---
title: 3.构造凸包
category:
  - 待归档
  - 计算几何
  - 凸包
---
## Extreme Point(极点算法)
### 思路
- 在点集中，只要能把所有极点甄别出来，则这些极点构成的图形即为凸包
  - 所以把构造凸包的问题规约成甄别极点的问题
### 判断点是否是极点
- 使用ITT判断该点是否在三角形内部，若其在三角形内部，则其必然不是极点
### 实现
1. 先假定所有的点都是极点
2. 枚举出所有可能的三角形
3. 对每一个三角形，要判断除这三个点之外的每一个点s，如果发现s落在当前三角形的内部，则其不是极点 
4. 时间复杂度O(n^4)

## Extreme Edge(极边算法)
### 思路
- 在点集中，只要能把所有极边甄别出来，则这些极边构成的图形即为凸包
    - 所以把构造凸包的问题规约成甄别极边的问题
### 判断边是否是极边
1. 对每一条边做TLT，若所有的点都在该边左侧，则该边为极边，构成该边的点，必定是极点
2. 时间复杂度O(n^3)

## 递增式策略算法
- Decrease and Conquer，又叫做Incremental Strategy递增式策略、蚕食策略，思想是减而治之(例如插入排序)
  - 将整个待排序的序列存成线性结构
  - 在任何时候将序列分为两部分，已排序的部分和未排序的部分
  - 算法的每一步都是相同的，都是将未排序中的第一个拿出来，在已排序的序列中找到一个合适的插入位置并插入，即规约，蚕食策略   
### 思路
1. 先找出任意的一个三角形，增加点，若该点能将三角形扩展成四边形（size变成4），则该点是极点。
2. 继续加点，若该点能将四边形扩展成为五边形，则该点是极点，直到所有点遍历完。
- 特殊情况
  - 点加进去后，size减少（已经是极点的点变成非极点），但该点是极点 
  - 重点在于如何区分不同的情况，并做相应的处理
3. 时间复杂度O(n^2)
### 实现
1. 判断新点是在多边形内部还是外部：In Convex Polygon Test
   - 新引入的点是否落在当前这个凸包的外面，若在外面，则其就是下一个极点，否则不是
   - 使用TLT判断点在多边形内部或外部：沿着凸多边形的边界做CCW（逆时针旋转遍历），会经过一段一段的边界，在每一段上，若一个点在左侧，则它是极点，若在右侧，则落在外部，所以时间成本变成了size，即n
2. 若凸多边形给定，将多边形预处理，有序向量的高效查找算法:二分查找，先将凸多边形的点排序，以凸多边形的一个点作为基础，在其余的n-1个点中，可以找到一个居中的点（middle point），将这两个点确定成一个有向直线，做一次TLT，将一个未知的点判断其在左边还是右边，无论在那边，都可以将搜索的范围收缩成原来的一半。在剩下的范围中找到一个middle point，再确定有向直线，再做TLT...最终范围是一个三角形，将问题退化成ITT（归约）
   - 这个方法的O是logn，因为原始凸多边形规模为n，范围折半降低，最多logn步之后（每一步的时间成本是常数，归约成最简单的情况
   - 但是该方法不行，因为最初的凸包不是静态的，和插入排序的sorted部分一样，都不是静态的，都是在随着算法执行的过程中不断变化，而凸包的size有可能减少有可能增大、持平。
3. 改进:若希望快速的完成In Convex Polygon Test，凸包的结构必须存成vector的结构，从而支持call-by-rank方式。
4. 若确定了一个极点，如何将其增加到凸包中：
   - 将凸包分为两部分，逆时针时，一部分是稳定的极边，一部分是将要扩展的极边，将稳定极边保留，将要扩展的极边丢弃。关键是如何判断这两种极边，即确定这两个区域切面的端点，切线tangent（support line）
   - 如何确定支撑线：对于一个点做两次TLT确定某个顶点到底属于那种极边路径(共有四种情况)
      1. 稳定极边环路上的顶点：从外部点到该稳定极边上的任意一点（非边界的两个顶点），发出一条有向直线，该边界上的点v在逆时针方向上有一个直接的前驱和一个后继，对前驱和后继点做TLT，测试结果true标记为L，false标记为R（分别代表left和right）。给每一个顶点添加属性pattern，该v点的pattern是right和left，即R+L。该稳定区域凸包环路上的所有点的pattern都是R+L
      2. 扩展极边环路上的顶点：pattern是L+R
      3. 第一个缝合点：外部顶点和它的连线，做两次TLT，其余点都在线的左侧，它的patten是L+L
      4. 第二个缝合点：外部顶点和它的连线，做两次TLT，其余点都在线的右侧，它的patten是R+R

::: tip
总结：
1. 任何一个点，不管该点在凸包外部还是内部都从凸包边界上的任何一个点出发，做一个CCW遍历，在遍历的过程中，每到达一个顶点，对其做两次TLT，判断出其pattern。
2. 若出发点在扩展极边环路上，迟早会到达第一个缝合点，从而确定一条tangent。然后会到达第二个缝合点，从而确定第二条tangent。
3. 若新点在内部，则外部区域全部都是扩展极边环路，每一个点都是r+l
4. 即只要对凸包的边界相对于新引入的点，做一趟遍历，就可以区分出来它到底是落在内部还是落在外部，且当落在外部时，找出这两个缝合点，从而确定应该舍去哪段极边环路，应该保留哪段极边环路，和将新引入的点缝合在什么位置。
5. 所以一次插入的成本是O(n) ，而整个的步骤是n，所以复杂度是O(n^2)
:::

## Jarvis March算法(Gift-Warpping，GW算法)
### 选择排序的思路
- 每次都维护一个局部解，在尚未处理的部分中，找到一个与当前的局部解紧密关联的元素(即那个最大的元素)
- 在未排序的序列中找到当最大的元素(注意和插入排序不同，插入排序是找到第一个元素)，将其移动到排序好的序列的首部
### GW算法的思路
- 思路与选择排序思路相似 
- 从一个极点k出发，在众多点当中找到下一个极点s，将ks连线称为极边，以s出发...，最终回到极点k，变成一个封闭的环
   - 规约为：立足为最后一个endpoint，如何去找到下一个极边，并在这个方向将凸包向前扩展
     - 重点是如何找下一个极边
       - 当前极点k，前驱i，下一个极边另外的一个极点为s
         - 如何找到s
         - s可能的情况：s是尚未处理的所有点的任何一个
           - s怎么检测为极点
             - ik这条极边。右侧为空，其余点在ik左侧，这些点与k连接，ks和ik的角度最小，则s是下一个极点(数学三角函数方法，不采用)
             - 剩下每个点又都可能是极点，当遍历到某个点s时，以ks有向直线出发，判断下一个点在其左侧还是右侧，若在右侧，则当前s需要更新(其角度更大，不符合)，若在左侧，则当前s为暂定的极点，直到其余点判断完
- 与极边算法的区别，极边算法因为要考虑所有的可能的边（n^3），且对每个边进行检测(n)，高达(n^3)
- 根据选择排序的思路，将下一个待检测边的范围缩小，而不是随机查找进行检测
### 通过极角排序找到下一个极点
#### 方法一：数学方法
以k的前驱结点i，构成一个有向直线。计算直线和其他各个点的角度，角度最小的是极点（s）
但是数学方法包含除法、三角函数，会造成误差
#### 方法二：TLT
1. 遍历所有的点，筛选。
2. 找到第一个极点k和第一条极边
- 第一个极点：lowest point，沿着y轴负轴最低的点，若其不会退化，则其必然是一个ep。
- 注意，若有歧义点（即最低点不唯一），则选择其中的最左侧的点leftmost point，该点称为lowest-then-leftmost point（LTL）
- 为了解决退化问题，习惯将第一条边认为是x轴正方向的边（即便实际情况不是如此，假象以第一个ep为圆心，将所有元素做一个假想式旋转，使得第一条ee水平向右
- 随机遍历到一个点a，然后从k出发，做一条有向直线，做TLT判断下一个待定的点在这条直线的左侧还是右侧，如果在左侧，则该待定的点重要性不如点a，即不是极点，若在右侧，则该待定的点是新的极点
- 常见的情况：当ks有向直线上还有别的点，不止s(他们角度相同)，如何讨论？后面详解，目前假设没有歧义的点

### GW的实现方法
```c
// LTL的查找算法伪码
int LTL(Points S[],int n){
   int ltl = 0;
   for (int k = 1;k < n;k++)
   {
      if(P[k].y < P[ltl].y || (P[k].y == P[ltl].y && P[k].x < P[ltl].x))
         ltl = k;
   }
   return ltl;
}
```
```c
// GW算法伪码
void Jarvis(Point S[],int n)
{
   // 遍历所有的点，并标记为非极点
   for (int k = 0;k < n;k++)
      S[k].extreme = FALSE;
   // 找到ltl并作为第一个点k
   int ltl = LTL(S,n);int k = ltl;
   do{
      // 第一个点k就是极点，且进入循环的都是极点
      P[k].extreme = TRUE;
      // 候选点s可以是任何一个点
      int s = -1;
      // 下一个点t可以在任何位置
      for (int t = 0;t < n;t++)
         // !ToLeft表示t在右侧
         if(t != k && t != s &&(s == -1 || ! ToLeft(P[k],P[s],P[t])))
            // 更新候选者s
            s = t;
      // 将最终的s标记为极点
      P[k].succ = s;
      k = s;
   }while(ltl != k);
}
```
### GW算法和Incremental Strategy算法的比较
1. GW算法具有输出敏感性
- 凸包的大小the size of the convex hull（h），h是构造过程中行进的步数
- 最坏的情况：累计行进h步，每一步成本是n，所以是n*h,当步数=n时是最坏的情况，时间复杂度是n^2（与IS相当）
- 最好的情况：步数是3，是常数步，每一步成本是的n
- GW的时间时间复杂度与运气、size有关，然而size是凸包构造出来后才能知晓的（这种度量方式叫做output sensitivity，算法叫output sensitivity algorithms）
- 所以想在构造之前就想得到成本大小，要用后面学的chan算法。
- chan算法利用了输出敏感性，使得算法能自适应的先确定output size，从而能选取一个合适的计算路线


## 曹冲称象之计算几何中的lower bound问题
- 从极点算法、极边算法...复杂度不断降低，在不穷举出所有算法时，如何直到构造凸包这类算法的时间复杂度最优是多少？
  - 在讨论凸包这类问题时，首先应该估算其下界
对于一个问题，最好的算法不会低于下界lower bound，在设计某个问题的算法之前，要先考虑一下lower bound是多少，然而不能直接去确定。所以要用归约的方法（reduction），将该算法的时间复杂度归约到另一个已知时间复杂度的算法上(注意规约的方向不要搞反)，通过取参照物知晓时间复杂度

线性规约：
- 左边已知下界的问题A，右边未知的问题B
  - 满足条件：A的任何一个输入都可以转化为B的一个输入。而B问题无论用什么算法，只要有一个输出，可以将其转化为A的输出。
    - 无论是输入的转化和输出的转化，都不能超出线性的时间
    - 此时，称A问题可以规约到B问题

曹冲称象：
用石头的重量估算出象的重量
   - 重点在于如何找到合适重量的石头
   - 凸包问题的石头就是**排序算法**
   - 合适的排序算法思想是找到凸包问题下界的重点
     - 一般的排序算法的下界是nlogn，所以一般凸包问题的下界也是nlogn
### 使用排序算法和凸包算法构造reduction
推算出凸包算法的下界是nlogn


## Gragham Scan算法(常用)
- 时间复杂度在最坏的情况下不会超过nlogn
### 思路
1. 先预处理排序presorting
   - 先找到ltl，然后将剩下的点进行极角排序
     - 任何排序算法都可，重点是将数字转换为点，**比较器**转换为tlt
   - 假设极角最小的那个点角度为0，在ltl的x轴上，且x轴上没有其他电
   - 假设任何连线上都不存在三点共线的情况
   - 感悟：设计算法时，先摈弃一切特殊情况，先按照一般情况来，再分门别类的讨论特殊情况，这样不会遗漏特殊情况，且易于理解。
     - 感悟：将最简单的情况运行一遍普通情况算法，再向数据中加入已知的非极点
   - 需要两个栈T和S，T开口向下，S开口向上
     - 思考：为什么设计这个算法，需要两个栈
       - 栈先进后出，后进先出，tlt为true时，入栈，入的是暂时的极点。继续遍历tlt，若tlt为false，则出栈
     - 将找到的tlt和假定特殊的点推入S，tlt在栈底，2在栈顶。其他n-2个点推入T，n在栈底，3在栈顶
2. 进行狭义上的graham scan
   - 重点是三个指针
     - S的栈顶和次栈顶记为S[0],S[1]、T的栈顶T[0]
   - 重点是判断这三个元素的tlt关系
     - S[0],S[1]必然是当前的极边
     - 若T[0]和[0],S[1]做tlt，若在左侧，则当前极边依旧是极边、凸包向前拓展一条极边，否则当前凸包回溯一条边
   - 循环结束的条件，T中没有任何元素，此时S中自底而上的点便是所有极点，且是逆时针的环路描述
### JS实现
```js
export default class ConvexHull {
    constructor(data) {
        this.data = data;
    }

    // 获取凸包
    // pointSet数据结构:[{lon: 107.1493, lat: 26.3617},{x2,y2}...]
    // pp:极点数组
    getConvexHull() {
        // 极角排序
        var temp_pxy = this.polarAngleSort(this.data);

        var pp = []
        pp.push(temp_pxy[0]);
        pp.push(temp_pxy[1]);
        pp.push(temp_pxy[2]);

        var top = 2;
        // 从第四个开始
        for (let i = 3; i < temp_pxy.length; i++) {

            // 待判定元素，pp栈顶两个元素
            // 不能用if判断，退不到正确的
            while (!(this.judgeTLT(pp[top - 1], pp[top], temp_pxy[i]) > 0)) {
                top--;
                pp.pop();
            }
            top++;
            pp.push(temp_pxy[i]);
        }
        return pp
    }

    // 极角排序
    polarAngleSort(data) {

        var lowestPoint = this.findLowestPoint(data);
        //计算极角(COS)
        for (var i = 0; i < data.length; i++) {
            // 若目标点是lp
            if (data[i] == lowestPoint) {
                data[i].angle = 999
            } else {
                // 目标点和lp连线与水平向右的极角角度的余弦值
                var cosineValue = (data[i].lon - lowestPoint.lon) / this.getDistance(data[i], lowestPoint);
                data[i].angle = cosineValue
            }
        }
        //升序，顺时针排列
        // var pointSetSort = data.sort((a,b)=>{ return a.angle-b.angle})
        //降序,逆时针排列
        var pointSetSort = data.sort((a, b) => { return b.angle - a.angle })
        return pointSetSort;
    }

    // 查找lowest point
    findLowestPoint(data) {
        if (data.length == 0) {
            return null;
        }
        var lowestPoint = data[0];
        for (var i = 1; i < data.length; i++) {
            if (data[i].lat < lowestPoint.lat || (data[i].lat == lowestPoint.lat && data[i].lon < lowestPoint.lon)) {
                lowestPoint = data[i];
            }
        }
        return lowestPoint;
    }

    //计算距离
    getDistance(firstPoint, secondPoint) {
        return Math.sqrt((firstPoint.lon - secondPoint.lon) * (firstPoint.lon - secondPoint.lon) + (firstPoint.lat - secondPoint.lat) * (firstPoint.lat - secondPoint.lat));
    }

    //计算向量叉积
    judgeTLT(firstPoint, secondPoint, thirdPoint) {
        return ((secondPoint.lon - firstPoint.lon) * (thirdPoint.lat - firstPoint.lat) - (thirdPoint.lon - firstPoint.lon) * (secondPoint.lat - firstPoint.lat));
        // 面积小于0，三个向量顺时针排列，第三个点在向量右侧，tlt为false
    }
}

```

### JTS中的实现
```java
@Test
public void testConvexHull() throws ParseException {
    WKTReader wktReader = new WKTReader(JTSFactoryFinder.getGeometryFactory(null));
    Geometry geometry = wktReader.read("MULTIPOINT ((51.289734885341495 33.69286578202587), (7.399467919044356 48.00497335017078), (3.8150643676406415 39.64040104840451), (8.327673215282417 86.95435524119337), (95.05951476094604 7.469261349936717), (29.998551598671796 67.67443392311351), (83.0903248885891 77.16170117259138), (79.91234431784049 29.541833005917006), (58.59337597657491 30.458753296480978), (26.74811753087868 25.965115424061857), (15.749374541600892 44.67264151128831), (29.190213361869443 15.635429086453655), (53.995480970254405 56.117673225898145), (97.98539936333401 13.55587356339698), (89.99664360014457 32.527876287222966), (7.713233340694048 27.829139654306733), (15.498725606296526 20.333593770573266), (7.662363492881575 13.749502964951665), (71.20799252448417 2.2981305211842495), (42.240620743917646 35.4365552706416), (19.439344280482164 73.76946161192059), (80.50689952897717 37.06451194155546), (88.99820725217555 21.68088516946537), (71.698018799338 90.6823657147522), (34.6087230269996 69.438482202305), (89.03386953299533 5.686495088737987), (0.1735248303230019 32.962071878110336), (97.61934057345229 56.19879714773378), (0.2480247946162639 18.400303777632665), (83.92164897875118 6.919792567857108), (37.33478852793236 80.41943167316305), (14.08689451478098 95.46759392791245), (53.9512820960392 51.46919316403573), (46.26974804862891 59.77996588002227), (77.89685280085165 47.05815204551137), (8.185429669440058 82.84819651013032), (56.74254108137459 49.824778535430504), (65.25317973827472 63.867818490156566), (93.28989163687379 76.06938385040282), (46.98571581917867 14.832719549798245), (87.59270851435144 32.4160240582257), (69.68917008976852 24.665491847626253), (63.10819265553146 77.40230835957898), (92.07330694718233 29.1683540766669), (4.641731150761652 13.049025736063523), (67.0318613800131 74.39533908574897), (63.97211358695824 44.840337259653666), (7.638071244362099 63.4878492682342), (95.3917120591234 65.0492747644185), (68.31059389849993 32.5821464346866), (67.86877232847546 33.972095818114354), (53.140154687881655 10.088643298501376), (63.13659859842679 56.38902613671086), (2.527452158919452 75.45936365184073), (9.73714347798863 76.44780702830073), (76.56798301132619 48.50132486902805), (21.894077140349054 43.17034356089526), (49.02962318081373 8.359938091172703), (9.063151169304017 30.911694917243192), (49.303920669491156 62.48802693549484), (97.10527423306954 34.35452324823276), (41.37226982207491 60.23240551992735), (55.2503931104886 96.0010494146314), (8.613235575620514 73.11136047597617), (54.36792537110365 65.62844900675547), (21.187486915054766 44.42284795040193), (91.5321474902028 35.80254786999555), (98.77196064692409 44.514541223138046), (3.4686013825313444 45.298552143867596), (45.57498581761823 54.863341047858846), (57.19023283307775 93.15650020328661), (26.84931956265525 44.053320931853335), (49.97963050123958 60.10298001959807), (76.5301474025382 91.8075200086748), (72.84640301644744 91.19960309018337), (74.16029808482382 63.420354497766006), (91.68636052479243 53.83260130640707), (5.925037687558121 36.25390062592864), (78.59186615595861 48.53684707051272), (29.40401567983828 32.402613753238676), (82.110341756078 16.651473403745353), (94.55803283504216 17.197550908907534), (59.7205641238272 58.43320444942036), (34.503512318764976 81.91249043208569), (8.394107166842046 48.007399318210595), (28.787676780804073 40.85078350134652), (19.8318364249931 7.4157128224140445), (59.16258507793073 37.933207325164865), (55.813134206548 81.02320169267384), (23.266387673654 75.97342924715224), (86.06809401907091 33.67658879943926), (45.15525887017613 53.01915404119807), (56.18063712752507 81.25932713911712), (23.289641600660527 14.453398656270677), (56.25313500898758 50.6679845239349), (86.36360117934986 6.991782041112938), (42.410795856527706 57.73841228384568), (85.2762639357706 51.27807448311468), (22.696704687404058 86.27902528731947), (35.57939583795192 33.47168951637892))");
    System.out.println(geometry.convexHull());
}
```
:::details 源码分析

```java
public Geometry getConvexHull() {
    // 兜底策略
    if (this.inputPts.length == 0) {
        return this.geomFactory.createGeometryCollection();
    } else if (this.inputPts.length == 1) {
        return this.geomFactory.createPoint(this.inputPts[0]);
    } else if (this.inputPts.length == 2) {
        return this.geomFactory.createLineString(this.inputPts);
    } else {
        // 三个点及以上
        Coordinate[] reducedPts = this.inputPts;
        
        if (this.inputPts.length > 50) {    // 数据量大的情况下，进行reduce(?)
            reducedPts = this.reduce(this.inputPts);
        }

        Coordinate[] sortedPts = this.preSort(reducedPts);  // 极角排序
        Stack cHS = this.grahamScan(sortedPts); // GS算法，获取凸包结果

        // 输出数据
        Coordinate[] cH = this.toCoordinateArray(cHS);
        return this.lineOrPolygon(cH);
    }
    
}
```
- 绿色的点为结果
- 绿色+橙色为`reduce`后的结果
- 灰色的点为舍弃掉的点
  ![源码分析](https://blog-image-9943.oss-cn-beijing.aliyuncs.com/202309171528544.png)
:::
::: details 调试技巧
- 打印`reducedPts`的结果，观察为何需要`reduce`这一步
  ![调试技巧](https://blog-image-9943.oss-cn-beijing.aliyuncs.com/202309171532107.png)
- 让执行日志执行以下代码，调试运行后，控制台中打印出`reducedPts`转为多点的WKT的结果，方便在`JTS TestBuilder`中验证
```java
StringBuilder sb = new StringBuilder();
sb.append("MULTIPOINT(");
for (int i = 0; i < reducedPts.length; i++) {
    if(i == reducedPts.length -1) {
        sb.append("(" + reducedPts[i].x + " " + reducedPts[i].y + ")");
    } else {
        sb.append("(" + reducedPts[i].x + " " + reducedPts[i].y + "),");
    }
}
sb.append(")");
String temp = sb.toString();
System.out.println(temp);
```
:::






