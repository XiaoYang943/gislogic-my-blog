---
title: 闭包
article: false
category:
  - JavaScript
---
## 闭包（closure）

### 闭包的本质
闭包的本质是局部数据共享

::: tip
组件的思想也是局部数据共享
:::
#### 如何创建闭包
当有局部数据共享（外层作用域和内层作用域共享同一个变量）就会创建闭包，与函数如何调用无关

```javascript
// 当两个函数都要用同一个变量时
// 方法一：使用全局变量
var a = 10;

function fn(){
  console.log(a)
}

function fn2(){
  console.log(a)
}

// 方法二：使用闭包
function fn3(){
  var a = 10;   //外层作用域

  function fn(){
    console.log(a)    //内层作用域
  }

  function fn2(){
    console.log(a)    //内层作用域
  }
}
```
### 闭包是什么
1. 使用chrome，debug调试查看
1. 理解一: 闭包是嵌套的内部函数(绝大部分人)
1. 理解二: 包含被引用变量(函数)的对象(极少数人)
1. 注意: 闭包存在于嵌套的内部函数中
### 怎么产生闭包
1. 两个函数嵌套，其中内部函数要使用声明式方法创建（否则函数定义不执行）
1. 内部函数引用了外部函数的变量或函数
1. 执行外部函数（因为不调用外部函数的话，内部函数不会定义)

### 闭包的作用
1. 使用函数内部的变量（局部变量）在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)。
2. 让函数外部可以操作(读写)到函数内部的变量或函数。因为在外面看不到局部变量，但是又要对局部变量进行操作
   - 实际需求：一个函数内部有一个变量，函数封装好了，想让外部能读，不能写
### 常见的闭包
#### 将函数作为另一个函数的返回值
```javascript
function fn1() {
  var a = 2   //如果断点在这，var a = 2还没有执行，但是闭包已经产生了，因为function fn2()函数声明提升了
  function fn2() {
    a++
    console.log(a)
  }
  return fn2    //函数也是数据，是数据就能传递
}
var f = fn1()   //此时a输出不了，因为fn2没有执行，但是闭包产生了
f() // 3
f() // 4
// 这段代码有一个闭包。而不是两个，因为只创建了一个内部函数对象，虽然是调用了两次f，但是是执行内部函数，而不是创建内部函数
// a是fn1的局部变量，执行fn1的时候产生，正常情况下a在调用结束后死亡，
```

#### 将函数作为实参传递给另一个函数调用
```javascript
function showMsgDelay(msg, time) {
  setTimeout(function () {
    console.log(msg)
  }, time)
}
showMsgDelay('hello', 1000)
```
### 闭包的生命周期
1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
2. 死亡: 在嵌套的内部函数成为垃圾对象时
```javascript
function fun1() {
  //此处闭包已经产生
  var a = 3;

  function fun2() {
    a++;
    console.log(a);
  }

  return fun2;
}
var f = fun1();

f();
f();
f = null //此时闭包对象死亡
```

### 闭包的应用
#### 定义JS模块
1. 具有特定功能的js文件
1. 将所有的数据和功能都封装在一个函数内部(私有的)
1. 只向外暴露一个包含n个方法的对象或函数，因为希望外部能操作他。如果不暴露，就会在执行后释放
1. 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能

### 闭包的缺点及解决
1. 缺点
- 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长(万事都具有两面性，不同情况下，特点有可能是优点，有可能是缺点)
- 容易造成内存泄露
2. 解决
- 能不用闭包就不用
- 及时释放

