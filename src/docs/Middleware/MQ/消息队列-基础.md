---
title: 消息队列-基础
article: false
category:
  - 中间件
  - MQ
---

## 同步通讯
- 场景
  - 使用Feign进行服务调用就属于同步方式
### 同步调用的优点
- 时效性较强，可以立即得到结果
### 同步调用存在的问题
![同步调用的问题](https://blog-image-9943.oss-cn-beijing.aliyuncs.com/202309091851728.png)

- 耦合度高
- 性能和吞吐能力下降
- 系统资源的浪费
- 有级联失败问题
### 存在的问题-耦合度高
- 举例：用户购买商品支付的案例
  - 用户调用支付服务，完成支付
  - 支付成功后，调用订单服务，修改订单状态
  - 订单状态改变后，调用仓储服务，发货
- 此时要加一个短信业务，当发货后，发短信给用户
  - 但此时在支付服务中，用Feign分别调用了订单和仓储服务
  - 而新加业务需要继续调用短信服务，需要在支付服务中继续**改动代码**
  - 每当有新增业务时，都要改动支付服务的代码，**代码耦合度高**，违背了开闭原则
### 存在的问题-性能和吞吐能力下降、系统资源的浪费、级联失败
- 举例：用户购买商品支付的案例
  - 用户调用支付服务，完成支付，需要200ms
  - 因为是同步调用，所以要**等待**支付成功后，**才能**调用订单服务，修改订单状态，需要150ms
  - 因为是同步调用，所以要**等待**订单状态改变后，**才能**调用仓储服务，发货，需要150ms
  - 且整个流程中，支付服务有两个**等待**过程，在该过程中，cpu和内存都在占用，导致系统资源的浪费
- 整个流程所花费的时间是**各个服务的响应时间之和**，即500ms
  - 所以该架构1s只能处理2个请求，性能低，当高并发时，g了
- 假设订单服务在高并发的情况下挂了，支付服务调用订单服务时，发生**阻塞**，请求不能释放，当支付服务资源耗尽后，支付服务也挂了，造成级联失败问题

## 异步通讯
- 异步调用常见的实现就是事件驱动模式，Broker是事件代理者
- 举例
  - 以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。
  - 在事件模式中，支付服务是事件发布者**publisher**，在支付完成后只需要发布一个支付成功的事件**event**，事件中带上订单id。就结束了，不需要等待其他三个服务。由Broker去通知其他三个服务该干活了，是一种异步的调用方式。
  - 订单服务和物流服务是事件订阅者**Consumer**，订阅支付成功的事件，监听到事件后完成自己业务即可。
  - 为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人**Broker**
    - 发布者发布事件到Broker，不关心谁来订阅事件
    - 订阅者从Broker订阅事件，不关心谁发来的消息。
    - Broker是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。
![事件驱动模式](https://blog-image-9943.oss-cn-beijing.aliyuncs.com/202309092104655.png)

- 优点
  - 耦合度降低：每个服务都可以灵活插拔，可替换
    - 因为支付服务不负责调用其他服务，而是只发送事件到Broker，其他的业务不用关心
    - 当有新的业务需求时，只需要订阅Broker事件
    - 当业务需求不要了，只需要取消订阅Broker事件
  - 吞吐量提升：无需等待订阅者处理完成，响应更快速
    - 总耗时不再是各个服务的响应时间之和了，只需要支付服务的耗时+发布事件的耗时
  - 故障隔离：服务没有直接调用，没有强的依赖关系，不存在级联失败问题，且调用间没有阻塞，不会造成无效的资源占用
  - 流量削峰：并发量不管多大，都由Broker接收，订阅者可以按照自己的速度去处理事件，Broker就相当于一个缓冲的作用![流量削峰](https://blog-image-9943.oss-cn-beijing.aliyuncs.com/202309092116303.png)
- 缺点
  - 架构复杂了，业务没有明显的流程线，不好管理
  - 需要依赖于Broker的可靠、安全、性能
## 两种调用方案的选择
- 当对服务的时效性较高时，采用同步调用的方法
- 当有高并发的情况时，且需要解耦时，采用异步调用的方法
## 消息队列
- 消息队列（MessageQueue，MQ），是存放消息的队列，也就是事件驱动架构中的**Broker**
- 常见的MQ实现
  - 追求可用性：Kafka、 RocketMQ 、RabbitMQ
  - 追求可靠性：RabbitMQ、RocketMQ
  - 追求吞吐能力：RocketMQ、Kafka
  - 追求消息低延迟：RabbitMQ、Kafka

|            | **RabbitMQ**            | **ActiveMQ**                   | **RocketMQ** | **Kafka**  |
| ---------- | ----------------------- | ------------------------------ | ------------ | ---------- |
| 公司/社区  | Rabbit                  | Apache                         | 阿里         | Apache     |
| 开发语言   | Erlang                  | Java                           | Java         | Scala&Java |
| 协议支持   | AMQP，XMPP，SMTP，STOMP | OpenWire,STOMP，REST,XMPP,AMQP | 自定义协议   | 自定义协议 |
| 可用性     | 高                      | 一般                           | 高           | 高         |
| 单机吞吐量 | 一般                    | 差                             | 高           | 非常高     |
| 消息延迟   | 微秒级                  | 毫秒级                         | 毫秒级       | 毫秒以内   |
| 消息可靠性 | 高                      | 一般                           | 高           | 一般       |
