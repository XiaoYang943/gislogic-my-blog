---
title: SpringFramework-AOP
article: false
category:
  - Java
  - Spring
---
## AOP
### 发现问题
- 针对带日志功能的实现类，有许多缺点  
  - 日志这种附加功能分散在各个业务功能方法中，且对核心业务功能有干扰，不利于统一维护
  - 如何解决
    - 解耦，需要把附加功能从业务功能代码中抽取出来
      - 困难
        - 要抽取的代码在方法内部**分散**存在，无法做到封装(封装是对一段连续逻辑的代码进行封装)
      - 解决
        - **代理模式**
- 代理模式
  - 通过提供一个代理类，使得在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中分离出来——**解耦**，有利于统一维护
  - **应用于AOP的四种通知**。
#### 静态代理
#### 动态代理
### AOP
- AOP是什么
  - AOP（Aspect Oriented Programming），面向切面编程思想，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现：在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。
  - 即横向抽取机制，把非核心代码抽取出来，交给切面类管理，然后套到目标对象，以实现不修改目标对象代码(**核心代码高内聚**)，动态添加额外功能进行功能增强(**附加功能和核心功能低耦合**)
- 横切关注点
  - 是从目标对象中要抽取出来的非核心业务
  - 一个方法中可以有多个横切关注点
- 通知方法
  - 每一个横切关注点上要做的事情都需要写一个方法来实现并封装到切面类中，这样的方法就叫通知方法。
  - 分类
    - 前置通知：`@Before`,在被代理的**目标方法前**执行
    - 返回通知：`@AfterReturning`,在被代理的**目标方法成功结束后**执行
    - 异常通知：`@AfterThrowing`,在被代理的**目标方法异常结束后**执行
    - 后置通知：`@After`,在被代理的**目标方法最终结束后**执行
    - 环绕通知：`@Around`,使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的**所有位置**
- 切面类
  - 封装通知方法的类
- 目标
  - 待用AOP进行功能增强的对象叫目标对象，即被代理的目标对象
- 代理
  - 在目标对象应用了通知后，为目标对象创建的代理对象，在AOP中，代理对象自动创建了，因为它封装了代理模式
- 连接点
  - 横切关注点不进要抽离出来，还要套用到原来的位置(连接点),为了不改变源代码而实现功能增强
    - 被套用了切面逻辑的方法就被切面给增强了。
- 切入点
  - 是连接点的代码表示，本质是个表达式，Spring 的 AOP 技术可以通过切入点定位到特定的连接点。
    - 例如：若连接点是数据库中的记录，那么切入点就是查询记录的SQL语句。
### 基于注解的AOP
- 技术架构
  - AspectJ注解层是AOP思想的一种实现方式
    - 本质上是静态代理，将代理逻辑织入(weaver)被代理的目标类编译得到的字节码文件，所以最终效果是动态的
  - 具体实现层
    - 动态代理，用于有接口的情况
      - JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口
    - cglib，用于没接口的情况
      - 通过继承被代理的目标类实现代理，所以不需要目标类实现接口。
- 依赖
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>5.3.1</version>
</dependency>
```
### 应用场景
1. 记录日志
2. 监控方法运行时间 （监控性能）
3. 权限控制
4. 缓存优化 （第一次调用查询数据库，将查询结果放入内存对象， 第二次调用， 直接从内存对象返回，不需要查询数据库 ）
   - 简单的＂方法缓存＂可以把＂方法名－参数＂作为Key，拦截器拦截方法根据＂方法名－参数＂去缓存系统查询，如果存在就直接返回，不需要执行方法真正的逻辑～
5. 事务管理 （调用方法前开启事务， 调用方法后提交关闭事务 ）
6. 用户登录
7. 调试（Debugging）
8. 懒加载（Lazy loading）
9.  错误处理（Error handling）
10. 资源池（Resource pooling）
11. 同步（Synchronization）
12. 限流
13. AES + RSA 加解密

### 编程式事务
- 缺点
  - 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。
  - 代码耦合度较高、复用性不高
```java
Connection conn = ...
try {
  // 开启事务：关闭事务的自动提交
  conn.setAutoCommit(false);

  // 核心操作

  // 提交事务 
  conn.commit();
}catch(Exception e){
  // 回滚事务 
  conn.rollBack();
}finally{
  // 释放数据库连接
  conn.close();
}
```
### 声明式事务
- 不用自己编写，交给框架，实现事务功能的切面和通知已经完成，只需要把通知套到连接点即可
- 既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。
  - 封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。
    - 好处1：提高开发效率
    - 好处2：消除了冗余的代码
    - 好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化
### 术语
### 基于注解的声明式事务
### 基于XML的声明式事务