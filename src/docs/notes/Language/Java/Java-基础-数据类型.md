---
title: Java-基础-数据类型
article: false
category:
  - Java
  - Java基础
---

## 数据类型
- JAVA是强类型语言，对于每一个变量需要定义明确的具体数据类型
### 基本数据类型
1. 数值型
   - 整数：byte、short、int(默认)、long
   - 浮点：float、double(默认)
2. 字符型：char
3. 布尔型：只有true和false，无null
4. 基本数据类型的转换：（自动类型转换）
   - 规范：
     - 有多种类型的数据混合运算时，系统首先自动将所有容量小的数据转换成容量最大的那种数据类型，然后再进行计算。
     - boolean类型不能与其它数据类型运算
     - 任何基本数据类型的值+String类型，基本数据类型的值将自动转化为String类型。
   - 总结：
     - char|byte|short -> int -> long -> float -> double
5. 强制类型转换：
  - 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出
  - 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。
    - `String a = “43”; int i = Integer.parseInt(a);`
6. 占用字节数
| 数据类型 | 字节数 |
| :-----| :----: |
| byte | 1 |
| boolean | 1 |
| short | 2 |
| char | 2 |
| int | 4 |
| float | 4 |
| double | 8 |
| long | 8 |
### 引用数据类型
1. 类
2. 接口
3. 数组

## 数组
- 数组是引用数据类型，而数组中的元素可以是任何相同的数据类型
- 创建数组对象会在内存中开辟一整块连续的空间，而数组引用的是这块连续空间的首地址。所以数组的长度一旦确定，就不能修改。
### 一维数组
1. 声明方式
   - `int a[]`，或`int[] a1`
   - 声明数组时不能指定其长度、
2. 初始化
- 动态初始化
```java
int[] arr = new int[3];
arr[0] = 3; arr[1] = 9; arr[2] = 8;
```
- 静态初始化
```java
int[] arr = {3,9,8};
```
### 常见异常
- 数组脚标越界异常(ArrayIndexOutOfBoundsException)
- 空指针异常(NullPointerException)
## 集合
### 集合
- 集合是一种容器，用于存储对象的引用
- 集合和数组的比较
|  | 数组 | 集合 |
| :-----: | :----: | :----: |
| 长度 | 初始化后，长度就不可变了，不便于扩展 | 长度是可以动态变化的 |
| 存放的数据 | 声明数组时就决定了数据的类型 | 可以存储不同的数据类型，默认都为Object |
| 实现方式 | 实现方式单一，开辟连续的存储空间 | 有List，Set，Map等实现方式 |



1. 数组在存储数据方面的弊端
   1. 数组初始化以后，长度就不可变了，不便于扩展
   2. 数组声明的类型，就决定了进行元素初始化时的类型,此时只能操作指定类型的数据。例如`String[] arr;`，`int[] arr` ,`Object[] arr`
   3. 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数
   4. 数组存储的数据是有序的、可以重复的
2. 集合的优点
   - 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。
3. 集合的接口
   - collection：
   - map
### Collection接口
- Collection接口是List、Set和Queue接口的父接口
- 单列集合，存储一个一个的数据
    - List接口：元素有序、可重复的集合，通常叫动态数组，因为可以拓展长度
    - Set接口：元素无序、不可重复的集合
         - 应用:过滤重复的数据
#### Collection接口的方法
### Iterator迭代器接口
### Collection子接口一：List
### Collection子接口二：Set
### Map接口
- 双列集合，以键值对的形式存储一对一对的数据
### Collections工具类

## 泛型
### 泛型概述
- 就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。
- 泛型比Object：
   - 解决元素存储的安全性问题
   - 解决获取数据元素时，需要类型强制转换的问题
- 好处：
   - 举例：String类型对象添加到String类型集合中，再从集合中读取某个String类型对象，不需要加强转
       - 只有指定的类型才能添加进去，**类型安全**
       - 读取出来的对象不需要强转，**便捷**
       - 可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加**简洁、健壮**。
### 在集合中使用泛型
### 自定义泛型结构
### 应用
- 当方法返回值类型因表的不同而不同时，返回值类型想到用Object，但是Object还要强转，所以用泛型
#### 声明泛型
声明时任意字母都可以。常用T表示，是Type的缩写。
## ==操作符与equals方法
### ==
- 基本类型比较值:只要两个变量的值相等，即为true。
- 引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。 
- 用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错
### equals
- 所有类都继承了Object，也就获得了equals()方法。还可以重写。
   - 只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。
   - 格式:`obj1.equals(obj2)`
   - 特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象
      > 原因：在这些类中重写了Object类的equals()方法。
- 当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等
  - 重写equals()方法的原则:
     - 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是 “true”。
     - 自反性：x.equals(x)必须返回是“true”。
     - 传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。
     - 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。
     - 任何情况下，x.equals(null)，永远返回是“false”；
     - x.equals(和x不同类型的对象)永远返回是“false”。
::: tip
- ==和equals的区别
   1. == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址
   2. equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。
   3. 具体要看自定义类里有没有重写Object的equals方法来判断。
   4. 通常情况下，重写equals方法，会比较类中的相应属性是否都相等。
:::
### toString() 方法
- toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。
- 在进行String与其它类型数据的连接操作时，自动调用toString()方法Date now=new Date();
```java
System.out.println(“now=”+now); 
// 相当于
System.out.println(“now=”+now.toString());
```
- 可以根据需要在用户自定义类型中重写toString()方法
- 基本类型数据转换为String类型时，调用了对应包装类的toString()方法


### 对象(实例)
#### 创建对象
- 创建类的对象，将java类实例化
- java类实例化的语法：类名 对象名 = new 类名()
- 访问对象成员的语法：对象名.对象成员

