---
title: Java-数据结构-哈希表
article: false
category:
  - Java
  - Java数据结构
---
## 引言
- 哈希表是由数组演化而来
  - 数组的特点
    - 占用内存情况：连续的内存空间
    - 访问性能：根据下标，直接访问，时间复杂度跟数据的规模没有关系，O(1)
### 发现问题
- 问题一：大量数据的情况下，因为数组是连续的内存空间，不可能存下所有的数据，数组的长度是有限的
- 问题二：散列冲突问题
### 解决问题
- 引入链表。假设十个元素的数组，当添加第11个元素时，将该元素以链表的形式连接到数组中某个元素上
  - 哈希表设计为：一个数组+多个链表组成，数组中存的是链表的头结点(形象化为梳子)，数组下标位置称为桶(bucket)或槽(slot)
  - 将散列值相同的元素存入相同槽位对于的链表中
### 发现问题
- 引入链表，性能降低
  - 没引入链表之前：根据哈希码拿到数组索引，拿到数据，O(1)
  - 引入链表之后：
    - 根据哈希码拿到索引(槽)，但是该索引指向一个链表，拿到的是该链表，想要确定是链表中的哪个元素，还要再遍历链表，此时时间复杂度和链表长度有关
      - 平均情况：每一个槽位只有一个链表节点，O(1)
      - 最坏情况：把元素挂在同一条链表中，遍历链表，O(n)
### 解决问题
- 在节省数组的占用空间和查询效率之间寻求一个平衡
  - 当链表过长时，将链表数据结构改为红黑树数据结构，O(logn)
- 优点
  - 数组+红黑树，减少连续内存的开辟，查询效率较高
  - 防止DDoS攻击
## 哈希表
- 数据结构：数组+红黑树
- 访问方式：根据键直接访问值
### 散列函数
- 将键(key)映射为数组下标的函数叫做散列函数。可以表示为：hashValue = hash(key)
- 基本要求
  - 散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。
  - 如果key1==key2，那么经过hash后得到的哈希值也必相同即：`hash(key1) == hash(key2）`
  - 如果key1 != key2，那么经过hash后得到的哈希值也必不相同即：`hash(key1) != hash(key2)`（不好实现）
### 散列冲突
- 实际的情况下想找一个散列函数能够做到对于不同的key计算得到的散列值都不同几乎是不可能的，即便像著名的MD5,SHA等哈希算法也无法避免这一情况，这就是散列冲突(哈希冲突，哈希碰撞)
  - 即多个key映射到同一个数组下标位置的情况
