---
title: V8引擎
article: false
category:
  - JavaScript
---
## JS的V8引擎的垃圾回收机制
### 作用
提升性能
### 过程
在内存中，周期性的遍历内存空间，当发现有垃圾就会回收。在代码中当一个变量不需要后，将其标记为null，等待回收。
### 底层原理
#### 名词解释
1. 引用
  - 内存的起始地址，知道了首地址和内存大小就能找到数据的来源
  - 弱引用(WeakMap WeakSet):相当于没引用
2. 垃圾
  - 没有任何引用的对象
3. 回收
  - 清除被垃圾占用的内存
  - 当程序的空闲时间时，即js主线程暂停时,回收
#### 引用计数法识别垃圾
1. 实现：给对象新增一个变量计数器，用来存储引用的次数
   - 每引用一次+1，null或{} -1，当计数器值为0时，该对象就成为了垃圾
::: tip
数组的length字段的维护方式相同
length返回数组的长度。当数组在创建的时候，length中就保存了数组初始化的长度。一旦对数组项的个数进行操作（push等），数组的长度为数组初始化的长度+数组改变的长度，而不是重新遍历数组获得长度，能提高性能。
:::
2. 优点：
   - 执行和实现简单、速度快
   - 实时反馈
3. 缺点：
  - 无法解决循环引用，容易造成内存泄露
#### 根搜索算法(TracingCollector,TC算法)识别垃圾
1. 哪些对象可以作为根节点
  - 所有正在运行的栈上的引用变量
  - 所有的全局对象、全局变量
  - 所有的内置对象
2. 实现
   - 先确定根节点
   - 将引用的标记为活跃对象，未被标记的即垃圾
3. V8引擎采用该方法
### V8的垃圾回收器Orinoco
#### V8的堆内存区域划分

1. 新生代Young Generation
   - 用于存储生命周期短的对象，如执行上下文
   - 大部分对象都会在新生代中死亡
   - 大多数对象都是隐式垃圾，用完即走
2. 老生代Old Generation
   - 用于存储生命周期长的对象，如函数声明
#### Major GC垃圾回收器
##### 作用
回收老生代的垃圾
##### Mark Sweep算法（标记-清除）
1. 将垃圾标记，然后清除
2. 缺点：会产生内存空隙
##### Mark Compact算法（标记-清除-整理）
1. 将垃圾标记，然后清除，然后整理内存空间
2. 优点：使得内存空间连续，方便分配连续的内存
#### Minor GC垃圾回收器(重要)
##### 作用
回收新生代的垃圾
##### GC复制算法
1. 算法思想:递归、深度优先
::: details
算法实现：
把新生代内存区域均等的划分成两个部分:From-Space和To-Space。To空间初始状态是空的，From空间初始状态也是空的，给From空间添加数据，当From空间满了之后，对From空间使用根搜索算法，找到活跃对象。找到活跃对象之后，先把根元素的子活跃对象B和G复制到To空间，此时还不能回收From空间的B，因为其引用A，回收了就找不到A这个活跃对象了。当A也找到后，也不能回收B，因为不能判断其他元素是否引用B。此时应该标记B，标记为B已经被复制过，当下次通过树的路径找到B时，就不复制B了。通过B找到A后，把A也复制到To空间，且给A打标记为已复制。GE同理。在这个状态下，垃圾和活跃对象已经完全分开，将From空间完全清空。然后将两个空间转换。转换后的结果，此时From空间就可以存储新的对象了。
:::
1. 优点
  - 当对象越来越多时，查找成本不会提高。因为大多数对象都会在新生代中死亡，到达老生代的很少
  - 不需要free-list记录分配空间，只需要一个$free指针，用来指向To空间的地址
1. 缺点
  - 根搜索算法是个递归的过程，根节点的第一个子节点找完之后，才找第二个子节点。在js中，递归函数会持续占用栈内存（执行上下文），当数据量大，递归会一直执行，栈内存可能不够
##### Cheney GC复制算法(V8采用该算法)
1. 算法思想：迭代、广度优先
::: details
算法实现：
引入新的指针$scan，用来将To空间模拟成队列。将根节点的第一个子节点入队，然后将根节点的第二个子节点入队...（注意这里和普通GC算法的区别）。此时scan指针遍历B，找到B的子节点，找到就入队，没找到就找G的子节点。scan指针一直遍历，直到和free指针指向同一地址，此时整个复制过程完毕。清理。交换
:::
1. 该算法思想和Promise执行队列相似。


### 总结
在实际开发中，大多数情况下不需要考虑GC，但是了解内部机制可以辅助优化代码。
1. 架构层：尽量避免全局状态的存在
2. 应用层
  - 短生命周期对象的使用成本较低，长生命周期对象的维护成本较高
  - 尽量减小闭包对象的大小（Vuex经常使用闭包）
