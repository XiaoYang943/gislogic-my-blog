---
title: MySQL-基础-数据查询语言
article: false
category:
  - 中间件
  - MySQL
---
## DQL
- DQL：Data Query Language数据查询语言，主要用于查询
```sql
select 
from 
join
on
where
group by
having
order by
limit
```
## 基础查询
- `select 查询列表 from 表名;`
  - 查询列表：字段、表达式、函数、常量值
1. 查询字段
   - 查询单个字段：`select 字段名`
   - 查询多个字段：`select 字段名1,字段名2...`
   - 查询所有字段：`select *`
   - 别名：`select 字段名 as 别名`，简写：`select 字段名 别名`
     - 提高可读性
     - 如果要查询的字段有重名的情况，使用别名可以区分开来
   - 去重：`select distinct 字段名`
## 条件查询
- `where 筛选条件`
1. 按条件表达式筛选
   - 简单条件运算符：
   - `> < = >= <=` 
   - `!= <>`
2. 按逻辑表达式筛选:用于连接条件表达式
   - 逻辑运算符：&& || ! and or not
   - &&和and：两个条件都为true，结果为true，反之为false
   - ||或or： 只要有一个条件为true，结果为true，反之为false
   - !或not： 如果连接的条件本身为false，结果为true，反之为false
     - not(表达式)：将表达式结果取反
### 模糊查询
1. like
   - `where 字段名 like '模糊查询条件'`
   - 一般和通配符搭配使用
     - % 任意多个字符,包含0个字符
     - _ 任意单个字符
     - 当要查询的字段中包含sql语言本身定义的通配符时：
       - `escape`关键字是用来定义转义字符，转义字符后的第一个字符被看做普通字符，而不是sql语言本身定义的通配符
         - `LIKE '_$_%' ESCAPE '$';`：指定`$`后的`_`为字段中的普通字符，而不是通配符`_`
2. between and
   - `BETWEEN 120 AND 100`
   - 取代`>= <=`,提高语句的简洁度
   - 包含临界值，且两个临界值不能调换顺序
3. in
   - `WHERE age IN(18,19,20)`;
   - 判断某字段的值是否属于in列表中的某一项
   - 提高语句简洁度
   - in列表的值类型必须一致或兼容
   - in列表中不支持通配符
4. is null和安全等于
   - =或<>不能用于判断null值
   - IS NULL:仅仅可以判断NULL值，可读性较高，建议使用
   - 安全等于<=>:既可以判断NULL值，又可以判断普通的数值，可读性较低,不建议使用
## 常见函数
`select 函数名(实参列表) [from 表名]`
1. 单行函数
2. 数学函数
3. 日期函数
4. 其它函数
5. 流程控制函数
## 分组查询
- `group by 分组的字段1,分组的字段2... `
  - 查询**每个**xxx，即分组为xxx
1. 分组前筛选:针对原始表
    - 一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率
```sql
where 
group by
```
1. 分组后筛选：针对groupby后的结果
```sql
group by
having
```
### 分组函数
- 用作统计使用，又称为聚合函数或统计函数或组函数
- sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数
- sum、avg一般用于处理数值型(忽略null值)
- max、min、count可以处理任何类型(忽略null值)
- 可以和distinct搭配实现去重的运算:`select 函数名(distinct 字段名) from 表名`
- 使用count(*)用作统计行数
- 和分组函数一同查询的字段要求是group by后的字段
- `select 函数名(字段名) from 表名`
## 连接查询
- 又称多表查询，当查询的字段来自于多个表时，就会用到连接查询
- 笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行
    - 发生原因：没有有效的连接条件
    - 如何避免：添加有效的连接条件
1. 按年代分类
   - sql92标准:仅仅支持内连接
   - sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接
2. 按功能分类
   - 内连接：等值连接、非等值连接、自连接
   - 外连接：左外连接、右外连接、全外连接
   - 交叉连接
```sql
from 表1 别名 [连接类型]
join 表2 别名 
on 连接条件
```
### 内连接inner
- **查询多表的交集**
```sql
select 查询列表
from 表1 别名
inner join 表2 别名
on 连接条件;
```
1. 分类：等值、非等值、自连接
2. 特点：
   - 添加排序、分组、筛选
   - inner可以省略
   - 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读
   - inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集
#### 等值连接
- on后的连接条件用`=`连接
- 三表连接
```sql
FROM employees e
JOIN departments d 
ON e.`department_id`=d.`department_id`
JOIN jobs j 
ON e.`job_id` = j.`job_id`
```
#### 非等值连接
- on后的连接条件用`between and`连接
#### 自连接
- 连接同一个表
```sql
select 查询列表
from 表1 别名
join 表1 别名
on 连接条件;
```
### 外连接
- **查询一个表中有，另一个表没有的记录**
- 外连接查询的结果是什么
  - 查询结果为主表中的所有记录
    - 如果从表中有和它匹配的，则显示匹配的值
    - 如果从表中没有和它匹配的，则显示null
    - 外连接查询结果=内连接结果+主表中有而从表没有的记录
- 左外连接，left join左边的是主表
- 右外连接，right join右边的是主表
- 注意
  - 左外和右外交换两个表的顺序，可以实现同样的效果 
  - 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的
## 排序查询
`order by 排序的字段、表达式、别名或函数 asc/desc`
- asc：升序，可以省略不写;
- desc：降序；
## 分页查询
- 应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求
`limit [offset,]size;`
- offset要显示条目的起始索引（起始索引从0开始）
- size 要显示的条目个数
```sql
LIMIT 0,5;
-- 简写为：
LIMIT 5;

-- 查询第11条——第25条
LIMIT 10,15;
```
## 子查询
- 出现在其他语句中的select语句，称为子查询或内查询，外部的查询语句，称为主查询或外查询
  - 子查询要被小括号包起来
### 标量子查询
- 子查询的结果集只有一行一列
### 列子查询
- 子查询的结果集只有一列多行
- 列子查询需要搭配**多行比较操作符**
  - in/not in：等于列表中的任意一个/列表中的全部都不是
  - any|some：和子查询返回的某一个值比较
    - 应用：
      - **任意一个**：`any()`
    - 可读性不高，可以由其他方式替换。例如：大于任何一个，替换为大于min()
  - all：和子查询返回的所有值比较
    - 应用：
      - **某一个**：`<>all()`
    - 可以被替换。例如：大于所有的，替换为大于max()
### 行子查询
- 子查询的结果集有一行多列
### 表子查询
- 子查询的结果集一般为多行多列
### 相关子查询
### 子查询出现的位置
  - select后面：
    - 仅支持标量子查询
  - from后面：
    - 表子查询
  - where或having后面：
    - 标量子查询
    - 列子查询
    - 行子查询
  - exists后面（相关子查询）
    - 表子查询
## 联合查询
- `union`
- 要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时，将多条查询语句的结果合并成一个结果
  - 要求多条查询语句的查询列数是一致的
  - 要求多条查询语句的查询的每一列的类型和顺序最好一致
  - union关键字默认去重，如果使用union all 可以包含重复项
## 标识列(自增长列)
- 不用手动输入的值，是系统提供默认的序列值
- 标识列不一定和主键搭配，要求是一个key
- 一个表最多有一个标识列
- 标识列的类型只能是数值型
- 标识列可以通过`SET auto_increment_increment=3;`设置步长
- 标识列可以通过手动插入值，设置起始值
## 约束
- 约束是一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性
- 分类
    1. NOT NULL:非空，用于保证该字段的值不能为空。比如姓名、学号等
    2. DEFAULT:默认，用于保证该字段有默认值。比如性别
    3. PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空。比如学号、员工编号等
    4. UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空。比如座位号
    5. CHECK:检查约束(mysql中不支持)。比如年龄、性别
    6. FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，在从表添加外键约束，用于引用主表中某列的值。比如编号id
- 什么时候添加约束
    1. 创建表时
	2. 修改表时
- 约束的添加分类：
	1. 列级约束：六大约束语法上都支持，但外键约束没有效果
	2. 表级约束：除了非空、默认，其他的都支持
- 外键
	1. 要求在从表设置外键关系
	2. 从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
	3. 主表的关联列必须是一个key（一般是主键或唯一）
	4. 插入数据时，先插入主表，再插入从表
	5. 删除数据时，先删除从表，再删除主表
### 创建表时添加约束
1. 添加列级约束
    - 语法：直接在字段名和类型后面追加约束类型即可。只支持：默认、非空、主键、唯一
2. 添加表级约束
    - 语法：在各个字段的最下面[constraint 约束名] 约束类型(字段名) 
### 修改表时添加约束
1. 添加列级约束：`alter table 表名 modify column 字段名 字段类型 新约束;`

2. 添加表级约束:`alter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用];`
