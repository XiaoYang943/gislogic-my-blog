---
title: Java-基础-面向对象
article: false
category:
  - Java
  - Java基础
---

## 面向对象
- JAVA面向对象程序设计的重点是类的设计，类的设计的重点是类的成员的设计
### 封装
- 高内聚:类的内部数据操作细节自己完成(隐藏对象内部的复杂性)，不允许外部干涉，否则接口使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或安全性问题
- 低耦合:仅对外暴露少量的接口用于使用
#### 封装的一种方式：隐藏
1. 隐藏什么
   - 将需要保护的属性进行隐藏
   - 隐藏一个类中不需要对外提供的实现细节
2. 隐藏的好处
   - 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作
   - 便于修改，增强代码的可维护性
3. 如何隐藏
   - Java中通过将数据声明为私有的(private)，再提供公共的(public)方法:getXxx()和setXxx()实现对该属性的操作
#### 访问权限修饰符
- public、protected、(缺省)、private，写于类的成员定义前，用来限定对象对该类成员的访问权限
- 对于class的权限修饰只可以用public和default(缺省)。
  - public类可以在任意地方被访问
  - default类只可以被同一个包内部的类访问
### 继承
1. 什么是继承
   - 多个类(子类)中存在相同属性和行为时，将这些公共内容抽取到单独一个类(父类)中，这些类无需再定义这些公共的属性和行为，只要继承那个类即可
     - 此处的多个类称为子类(派生类)单独的这个类称为父类(基类或超类)
   - 子类继承了父类，就继承了父类的方法和属性
   - 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法
2. 继承的语法规则
   - `class Subclass extends SuperClass{}`
3. 注意的点
   - 不要仅为了获取其他类中某个功能而去继承
   - 在Java中，继承的关键字用的是`extends`，即子类不是父类的子集，而**是对父类的“扩展”**。
   - 子类不能直接访问父类中私有的(private)的成员变量和方法。
   - Java只支持单继承和多层继承，不允许多重继承
      - 一个子类只能有一个父类  
      - 一个父类可以派生出多个子类
      ::: tip
         想要多重继承的效果，就要用接口实现
      :::
4. 继承的作用
   - 减少了代码冗余，提高了代码的复用性
   - 更有利于功能的扩展
   - 让类与类之间产生了关系，提供了多态的前提
#### 方法的重写
1. 什么是方法的重写
   - 在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重写。在程序执行时，子类的方法将覆盖父类的方法
2. 重写的规范
   - 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
   - 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
   - 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
      - 子类不能重写父类中声明为private权限的方法
   - 子类方法抛出的异常的范围不能大于父类被重写方法的异常
   - 子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static(不是重写)。因为static方法是属于类的，子类无法覆盖父类的方法。
3. 总结
   - 从编译和运行的角度看
     - 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
       - 对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
       - 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。
#### 子类对象实例化过程
#### 接口(interface)
1. 为什么用接口
   -  有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。
   -  有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有父子继承的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘都支持USB连接。
2. 本质
   - 标准，规范
3. 特点
   - 用`interface`来定义。
   - 接口中的所有成员变量都默认是由public static final修饰的。
   - 接口中的所有抽象方法都默认是由public abstract修饰的。
   - 接口中没有构造器。
   - 接口采用多继承机制。
4. 注意的点
   - 定义Java类的语法格式：先写extends，后写implements。`class SubClass extends SuperClass implements InterfaceA{}`
   - 一个类可以实现多个接口，接口也可以继承其它接口。
   - 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。
   - 接口的主要用途就是被实现类实现。（面向接口编程）
   - 与继承关系类似，接口与实现类之间存在多态性
   - 接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。
5. Java8对接口的改进:可以为接口添加静态方法和默认方法
   - 静态方法：使用 `static` 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。
   - 默认方法：默认方法使用 `default` 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。
      - 若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突的问题。
         - 解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。
      - 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。
         - 因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。
6. 接口与抽象类的对比
|  | 抽象类 | 接口 |
| :-----| :----: | :----: |
| 定义 | 构造方法、抽象方法、普通方法、常量、变量 | 常量、抽象方法、(jdk8.0:默认方法、静态方法) |
| 组成 | 访问本类中的方法，如果本类没有此方法则从父类中继续查找 | 直接访问父类中的方法 |
| 使用 | 子类继承抽象类(extends)  | 子类实现接口(implements) |
| 关系| 抽象类可以实现多个接口 | 接口不能继承抽象类，但允许继承多个接口 |
| 常见设计模式 | 模板方法 | 简单工厂、工厂方法、代理模式 |
| 局限 | 抽象类有单继承的局限 | 接口没有此局限 |
| 实际 | 作为一个模板 | 是作为一个标准或是表示一种能力 |
| 对象 | 都通过对象的多态性产生实例化对象 |
| 选择 | 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 |
::: tip
在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。
:::
#### 接口的应用
##### 代理模式(proxy)
##### 工厂设计模式
### 多态
1. 作用
   - 提高了代码的通用性，常称作接口重用
2. 前提
   - 需要存在继承或者实现关系
   - 有方法的重写
3. 成员方法
   - 编译时：要查看引用变量所声明的类中是否有所调用的方法。
   - 运行时：调用实际new的对象所属的类中的重写方法。
4. 成员变量
   - 不具备多态性，只看引用变量所声明的类。
5. 对象的多态性：父类的引用指向子类的对象 
   - 可以直接应用在抽象类和接口上
6. Java引用变量的两个类型：编译时类型和运行时类型。
   - 编译时类型由声明该变量时使用的类型决定。运行时类型由实际赋给该变量的对象决定
     - 简称：编译时，看左边；运行时，看右边。
   - 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
      - 多态情况下，“看左边”即看的是父类的引用（父类中不具备子类特有的方法）
      - 多态情况下，“看右边”即看的是子类的对象（实际运行的是子类重写父类的方法）
7. 对象的多态
   - 在Java中,子类的对象可以替代父类的对象使用
      - 一个变量只能有一种确定的数据类型
      - 一个引用类型变量可能指向(引用)多种不同类型的对象
   - 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)
   - 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法
#### 虚拟方法调用(Virtual Method Invocation)
子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
#### instanceof 操作符
`B instanceof A`:检验B是否为类A的对象，返回值为boolean型。
   - 要求B所属的类与类A必须是子类和父类的关系，否则编译错误。
   - 如果B属于类A的子类，B instanceof A值也为true。
#### 对象类型转换(Casting)
1. 基本数据类型的转换
   - 自动类型转换：小的数据类型可以自动转换成大的数据类型
   > 如long g=20; double d=12.0f
   - 强制类型转换(造型)：可以把大的数据类型强制转换(casting)成小的数据类型
   > 如float f=(float)12.0; int a=(int)1200L
2. 强制类型转换
   - 从子类到父类的类型转换可以自动进行
   - 从父类到子类的类型转换必须通过造型(强制类型转换)实现
   - 无继承关系的引用类型间的转换是非法的
   - 在造型前可以使用instanceof操作符测试一个对象的类型
   - 较高级的基本数据类型————>较低级的基本数据类型:强制类型转化
   - 较低级的基本数据类型————>较高级的基本数据类型:自动类型提升
   - 父类————>子类：向下转型，使用instanceof进行判断
   - 子类————>父类：向上转型：多态
#### 子类继承父类
- 若子类重写了父类方法，则子类里定义的方法覆盖了父类里的同名方法
- 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量
#### 模板方法设计模式
抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。
1. 作用
   - 当功能内部一部分实现是确定的，一部分实现是不确定的(易变的)。这时可以把不确定的部分暴露出去，让子类去实现。
### 类
::: tip
JAVA面向对象程序设计的重点是类的设计，类的设计的重点是类的成员的设计。
类的成员有:属性、方法、构造器、代码块
:::
1. 类的语法格式:`修饰符 class 类名 {}`
2. 类的访问机制
   - 在同一个类中的访问机制：类中的方法可以直接访问类中的成员变量。（例外：static方法访问非static，编译不通过。）
   - 在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员。
#### Object类的使用
- Object类是所有Java类的根父类
- 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
```java
public class Person { ...
}
// 等价于：
public class Person extends Object { ...
}
```
#### 属性field
1. 属性对应类中的成员变量
2. 语法格式
   - `修饰符 数据类型 属性名 = 初始化值`
3. 修饰符
   - private、缺省、protected、public、static、final 
4. 数据类型
   - 任何基本数据类型或任何引用数据类型
##### 变量的分类
1. 成员变量：在方法体外，类体内声明的变量
   - 实例变量（不以static修饰）
   - 类变量（以static修饰）
2. 局部变量：在方法体内部声明的变量
   - 形参（方法、构造器中定义的变量）
   - 方法局部变量（在方法内定义）
   - 代码块局部变量（在代码块内定义）
3. 比较
|  | 成员变量 | 局部变量 |
| :-----| ----: | :----: |
| 声明的位置 | 直接声明在类中 | 方法形参或内部、代码块内、构造器内等 |
| 修饰符 | private、public、static、final等 | 不能用权限修饰符修饰，可以用final修饰 |
| 初始化值 | 有默认初始化值 | 没有默认初始化值，必须显式赋值，方可使用（除形参外） |
| 内存加载位置 | 堆空间 或 静态域内 | 栈空间 |
| 生命周期 | 有 | 有 |
##### 赋值的位置和先后顺序
- 默认初始化
- 显式初始化
- 构造器中初始化
- 通过`对象.属性`或`对象.方法`的方式赋值
#### 方法method
- 对应类中的成员方法,是类或对象行为特征的抽象，用来完成某个功能操作
- java里的方法不能独立存在，所有的方法必须定义在类里
-  声明格式：
```java
修饰符 返回值类型 方法名（参数类型形参1, 参数类型形参2, ….）{
   方法体程序代码
   return 返回值;
}
```
   - 修饰符:public,缺省,private, protected等
   - 返回值类型:若没有返回值则是void。若有返回值，声明出返回值的类型。
- 注意的点
   - 方法被调用一次，就会执行一次
   - 没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可以不必使用return语句。如果使用，仅用来结束方法。
   - 定义方法时，方法的结果应该返回给调用者，交由调用者处理
   - 方法中只能调用方法或属性，不可以在方法内部定义方法。
##### 方法的重载
- 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
- 特点：与返回值类型无关，只看参数列表，且参数列表必须不同(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。
- 快速区分两个方法是否重载：只要这两个方法的形参名有交集且方法名相同即重载，与其他均无关
<span id="重载"></span>

##### 如何传递实参
- 方法必须由其所在类或对象调用才有意义
- java中通过值传递的方法传递实参，即将参数值的副本传入方法内
- 若形参是基本数据类型，则将实参基本数据类型变量的“数据值”传递给形参
- 若形参是引用数据类型，则将实参引用数据类型变量的“地址值”传递给形参
##### 递归方法
- 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
- 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。
#### 构造器
1. 特征
   - 它具有与类相同的名称
   - 它不声明返回值类型。（与声明为void不同）
   - 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值
2. 作用
   - 创建对象
   - 给对象进行初始化
3. 语法格式
   - `修饰符 类名 (参数列表) {初始化语句}`
4. 类型
   - 隐式无参构造器（系统默认提供）
   - 显式定义一个或多个构造器（无参、有参）
5. 注意
   - Java语言中，每个类都至少有一个构造器
   - 默认构造器的修饰符与所属类的修饰符一致
   - 一旦显式定义了构造器，则系统不再提供默认构造器
   - 一个类可以创建多个重载的构造器
   - 父类的构造器不可被子类继承
6. 构造器重载
   - 构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。
   - 构造器重载，参数列表必须不同
#### 代码块(初始化块)
1. 作用
   - 对Java类或对象进行初始化
2. 分类
   - 静态代码块：用static修饰的代码块
      > 可以有输出语句。
      > 可以对类的属性、类的声明进行初始化操作。
      > 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。
      > 若有多个静态的代码块，那么按照从上到下的顺序依次执行。
      > 静态代码块的执行要先于非静态代码块。
      > 静态代码块随着类的加载而加载，且只执行一次。
   - 非静态代码块：没有static修饰的代码块
      > 可以有输出语句。
      > 可以对类的属性、类的声明进行初始化操作。
      > 除了调用非静态的结构外，还可以调用静态的变量或方法。
      > 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。
      > 每次创建对象的时候，都会执行一次。且先于构造器执行。
#### 内部类
1. 使用情况
   - 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。
   - 在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。
2. 注意的点
   - 非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。
   - 外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式
   - 成员内部类可以直接使用外部类的所有成员，包括私有的数据
   - 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的

##### 成员内部类（static成员内部类和非static成员内部类）
1. 成员内部类作为类的成员的角色
   - 和外部类不同，内部类还可以声明为private或protected
   - 可以调用外部类的结构
   - 内部类可以声明为static的，但此时就不能再使用外层类的非static的成员变量
2. 成员内部类作为类的角色
   - 可以在内部定义属性、方法、构造器等结构
   - 可以声明为abstract类 ，因此可以被其它的内部类继承
   - 可以声明为final的
   - 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）
##### 局部内部类（不谈修饰符）
1. 如何声明
```java
class 外部类{
   方法(){
      class 局部内部类{
      }
   }

   {
      class 局部内部类{
      }
   }
}
```
2. 如何使用
   - 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类
   - 但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型
3. 特点
   - 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和`$`符号，以及数字编号。
   - 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。
   - 局部内部类可以使用外部类的成员，包括私有的。
   - 局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。
   - 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private
   - 局部内部类不能使用static修饰，因此也不能包含静态成员
##### 匿名内部类
1. 使用情况
   - 匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。
2. 格式:`new 父类构造器（实参列表）|实现接口(){//匿名内部类的类体部分}`
3. 特点
   - 匿名内部类必须继承父类或实现接口
   - 匿名内部类只能有一个对象
   - 匿名内部类对象只能使用多态形式引用

## MVC设计模式
MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。
1. 模型层 model 主要处理数据
   - 数据对象封装 model.bean/domain
   - 数据库操作类 model.dao
   - 数据库 model.db
2. 视图层 view 显示数据
   - 相关工具类 view.utils
   - 自定义view view.ui
3. 控制层 controller 处理业务逻辑
   - 应用界面相关 controller.activity
   - 存放fragment controller.fragment
   - 显示列表的适配器 controller.adapter
   - 服务相关的 controller.service 
   - 抽取的基类 controller.base

## JAVA中重要的类
### Properties
<span id="properties"></span>

- Properties（Java.util.Properties）是Java中一个比较重要的类，主要用于读取Java的配置文件。
1. 规范
   - 文件名:以.properties结尾
   - 文件格式：文本文件
   - 文件内容格式：键=值
      - 注意：等号左右不要有空格，容易造成歧义
   - 文本内容注释：#
2. 如何读取文件中的配置
- `getClassLoader`获取该类的类加载器
- `getResourceAsStream`获取类路径下的指定文件的输入流
```
#以数据库连接配置文件为例
user=root
password=root
url=jdbc:mysql://localhost:3306/test?
driverClass=com.mysql.jdbc.Driver
```
```java
// 读取配置文件信息
InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream("jdbc.properties");

Properties pros = new Properties();
pros.load(is);

String user = pros.getProperty("user");
String password = pros.getProperty("password");
String url = pros.getProperty("url");
String driverClass = pros.getProperty("driverClass");
```


